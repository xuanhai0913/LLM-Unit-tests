import { useState } from 'react';
import { FiZap, FiAlertCircle, FiFileText, FiCheckCircle, FiPlay, FiArrowLeft, FiFolder, FiCpu } from 'react-icons/fi';
import toast from 'react-hot-toast';
import { analyzeTests, generateImprovements, runTests } from '../services/api';
import { useAuth } from '../contexts/AuthContext';
import '../styles/improveMode.css';

// Mock modules data - represents the backend of this project
const MOCK_MODULES = [
    {
        id: 1,
        name: 'sandbox.js',
        path: 'backend/src/services/sandbox.js',
        testFile: 'backend/tests/sandbox.test.js',
        tests: 3,
        coverage: 45,
        targetCoverage: 85,
        gaps: [
            { name: 'Timeout handling', lines: '85-92', priority: 'HIGH' },
            { name: 'Cleanup with permission errors', lines: '168-175', priority: 'MEDIUM' },
            { name: 'Coverage extraction from JSON', lines: '120-135', priority: 'HIGH' },
            { name: 'Invalid language handling', lines: '45-50', priority: 'LOW' }
        ],
        sourceCode: `class SandboxService {
    constructor() {
        this.tempDir = '/tmp/sandbox';
        this.timeout = 10000;
    }

    async executeTest(language, code, tests) {
        const runId = crypto.randomUUID();
        const workDir = path.join(this.tempDir, runId);
        
        try {
            await fs.mkdir(workDir, { recursive: true });
            
            if (language === 'python') {
                return await this._executePython(workDir, code, tests);
            } else if (language === 'javascript') {
                return await this._executeNode(workDir, code, tests);
            } else {
                throw new Error('Unsupported language: ' + language);
            }
        } finally {
            await this._cleanup(workDir);
        }
    }

    async _cleanup(workDir) {
        try {
            await fs.rm(workDir, { recursive: true, force: true });
        } catch (err) {
            console.error('Cleanup failed:', err);
        }
    }
}`,
        existingTests: `describe('SandboxService', () => {
    let sandbox;

    beforeEach(() => {
        sandbox = new SandboxService();
    });

    it('should execute Python code successfully', async () => {
        const result = await sandbox.executeTest('python', 'print("hello")', 'def test_hello(): pass');
        expect(result.success).toBe(true);
    });

    it('should execute JavaScript code successfully', async () => {
        const result = await sandbox.executeTest('javascript', 'console.log("hi")', 'test("hi", () => {})');
        expect(result.success).toBe(true);
    });

    it('should parse pytest output correctly', async () => {
        const output = '====== 5 passed in 0.12s ======';
        expect(sandbox._parseOutput(output, 'python').passed).toBe(5);
    });
});`
    },
    {
        id: 2,
        name: 'auth.js',
        path: 'backend/src/routes/auth.js',
        testFile: 'backend/tests/auth.test.js',
        tests: 3,
        coverage: 35,
        targetCoverage: 80,
        gaps: [
            { name: 'JWT token validation', lines: '45-60', priority: 'HIGH' },
            { name: 'OAuth callback handling', lines: '120-145', priority: 'HIGH' },
            { name: 'Password strength validation', lines: '75-85', priority: 'MEDIUM' },
            { name: 'Rate limiting', lines: '200-215', priority: 'LOW' }
        ],
        sourceCode: `// Auth routes`,
        existingTests: `// Auth tests`
    },
    {
        id: 3,
        name: 'testGenerator.js',
        path: 'backend/src/services/testGenerator.js',
        testFile: 'backend/tests/testGenerator.test.js',
        tests: 4,
        coverage: 40,
        targetCoverage: 80,
        gaps: [
            { name: 'Error handling for API failures', lines: '55-70', priority: 'HIGH' },
            { name: 'Retry logic', lines: '90-105', priority: 'MEDIUM' },
            { name: 'Multiple framework support', lines: '120-140', priority: 'MEDIUM' }
        ],
        sourceCode: `// Test generator service`,
        existingTests: `// Test generator tests`
    }
];

// Mock generated tests
const MOCK_GENERATED_TESTS = `// ===== ADDITIONAL TESTS GENERATED BY LLM =====
// Filling coverage gaps for sandbox.js

describe('SandboxService - Additional Tests', () => {
    describe('Timeout Handling', () => {
        it('should kill process after 10 seconds timeout', async () => {
            const infiniteLoop = 'while True: pass';
            const result = await sandboxService.executeTest('python', infiniteLoop, '');
            expect(result.error).toContain('timed out');
            expect(result.success).toBe(false);
        });

        it('should return partial output before timeout', async () => {
            const slowCode = 'import time; time.sleep(15)';
            const result = await sandboxService.executeTest('python', slowCode, '');
            expect(result.duration).toBeGreaterThanOrEqual(10000);
        });
    });

    describe('Cleanup with Permission Errors', () => {
        it('should use Docker for cleanup when permission denied', async () => {
            const result = await sandboxService._cleanup('/tmp/test-run-123');
            expect(result).toBe(true);
        });

        it('should log cleanup errors without throwing', async () => {
            const consoleSpy = jest.spyOn(console, 'error');
            await sandboxService._cleanup('/nonexistent/path');
            expect(consoleSpy).toHaveBeenCalled();
        });
    });

    describe('Coverage Extraction', () => {
        it('should parse coverage from JSON report', async () => {
            const mockCoverageJson = { totals: { percent_covered: 92.5 } };
            const coverage = sandboxService._parseCoverage(mockCoverageJson);
            expect(coverage).toBe(93);
        });
    });

    describe('Invalid Language', () => {
        it('should throw error for unsupported language', async () => {
            await expect(
                sandboxService.executeTest('cobol', 'code', 'test')
            ).rejects.toThrow('Unsupported language');
        });
    });
});`;

function ImproveTests() {
    const { user } = useAuth();

    // State
    const [selectedModule, setSelectedModule] = useState(null);
    const [isGenerating, setIsGenerating] = useState(false);
    const [generatedTests, setGeneratedTests] = useState('');
    const [generationTime, setGenerationTime] = useState(null);
    const [llmProvider, setLlmProvider] = useState('gemini');

    // GitHub scan state
    const [githubUrl, setGithubUrl] = useState('');
    const [isScanning, setIsScanning] = useState(false);
    const [scannedModules, setScannedModules] = useState([]);
    const [projectInfo, setProjectInfo] = useState(null);

    const API_URL = import.meta.env.VITE_API_URL || '/api';

    // Use scanned modules if available, otherwise mock data
    const modules = scannedModules.length > 0 ? scannedModules : MOCK_MODULES;

    // Calculate average coverage
    const avgCoverage = Math.round(modules.reduce((sum, m) => sum + m.coverage, 0) / modules.length);

    // Scan GitHub for modules with existing tests
    const handleScanGithub = async () => {
        if (!githubUrl.trim()) {
            toast.error('Please enter a GitHub URL');
            return;
        }

        setIsScanning(true);
        try {
            const response = await fetch(`${API_URL}/scan/github`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: githubUrl })
            });

            const data = await response.json();

            if (data.success) {
                // Just list files without analyzing - user will select which to analyze
                const scannedFiles = data.data.files.map((file, idx) => ({
                    id: idx + 1,
                    name: file.name,
                    path: file.path,
                    testFile: `tests/${file.name.replace('.py', '_test.py').replace('.js', '.test.js')}`,
                    tests: '?',
                    coverage: null, // Will be set after analysis
                    targetCoverage: 85,
                    gaps: [],
                    sourceCode: '',
                    existingTests: '',
                    url: file.url,
                    analyzed: false,
                    isAnalyzing: false
                }));

                setScannedModules(scannedFiles);
                setProjectInfo({
                    name: data.data.repoName,
                    files: data.data.files.length
                });
                toast.success(`Found ${data.data.files.length} files. Select a file to analyze.`);
            } else {
                toast.error(data.error || 'Failed to scan');
            }
        } catch (error) {
            console.error('Scan error:', error);
            toast.error('Failed to scan repository');
        } finally {
            setIsScanning(false);
        }
    };

    // Analyze a single module with LLM
    const handleAnalyzeModule = async (module) => {
        // Set analyzing state for this module
        setScannedModules(prev => prev.map(m =>
            m.id === module.id ? { ...m, isAnalyzing: true } : m
        ));

        try {
            // Fetch file content
            const contentRes = await fetch(`${API_URL}/scan/github/content`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: module.url })
            });
            const contentData = await contentRes.json();
            const sourceCode = contentData.success ? contentData.data.content : '';

            // Analyze with LLM
            let analysis = { gaps: [], estimatedCoverage: 30, totalFunctions: 0, testedFunctions: 0 };
            if (sourceCode) {
                toast.loading(`ü§ñ AI analyzing ${module.name}...`, { id: 'analyzing' });
                const analyzeRes = await fetch(`${API_URL}/analyze/file`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sourceCode,
                        fileName: module.name,
                        language: module.name.endsWith('.py') ? 'python' : 'javascript'
                    })
                });
                const analyzeData = await analyzeRes.json();
                toast.dismiss('analyzing');
                if (analyzeData.success) {
                    analysis = analyzeData.data;
                    toast.success(`Analyzed ${module.name}!`);
                }
            }

            // Update module with analysis results
            setScannedModules(prev => prev.map(m =>
                m.id === module.id ? {
                    ...m,
                    isAnalyzing: false,
                    analyzed: true,
                    sourceCode: sourceCode,
                    tests: analysis.testedFunctions || 0,
                    coverage: analysis.estimatedCoverage || 30,
                    gaps: analysis.gaps.length > 0 ? analysis.gaps : [
                        { name: 'No issues detected', lines: '-', priority: 'LOW', reason: 'Code looks good' }
                    ],
                    totalFunctions: analysis.totalFunctions || 0
                } : m
            ));
        } catch (error) {
            console.error('Analysis error:', error);
            toast.dismiss('analyzing');
            toast.error(`Failed to analyze ${module.name}`);
            setScannedModules(prev => prev.map(m =>
                m.id === module.id ? { ...m, isAnalyzing: false } : m
            ));
        }
    };

    const getCoverageColor = (coverage) => {
        if (coverage < 50) return 'coverage-low';
        if (coverage < 70) return 'coverage-medium';
        return 'coverage-high';
    };

    const handleModuleClick = (module) => {
        setSelectedModule(module);
        setGeneratedTests('');
    };

    const handleGenerate = async () => {
        if (!selectedModule) return;

        setIsGenerating(true);
        const startTime = Date.now();

        try {
            const language = selectedModule.language || 'javascript';
            const framework = language === 'python' ? 'pytest' : 'jest';

            const result = await generateImprovements({
                sourceCode: selectedModule.sourceCode,
                existingTests: selectedModule.existingTests || '',
                language,
                framework,
                gaps: selectedModule.gaps.map(g => g.name),
                llmProvider
            });

            if (result.success) {
                setGeneratedTests(result.data.additionalTests);
                setGenerationTime(result.data.generationTime);
                toast.success(`Generated ${result.data.newTestCount || 'new'} additional tests!`);
            } else {
                toast.error('Failed to generate improvements');
            }
        } catch (error) {
            console.error('Improvement error:', error);
            const msg = error.response?.data?.error || error.message;
            toast.error(`Error: ${msg}`);
        } finally {
            setIsGenerating(false);
        }
    };

    const handleRunTests = async () => {
        if (!generatedTests) return;
        const toastId = toast.loading('Running tests...');
        try {
            const language = selectedModule.language || 'javascript';
            // Run the generated code. In a real scenario we might merge with existing tests first.
            // For now, we assume generatedTests includes necessary mocks/setup or imports.
            // But usually we need source code presence?
            // The runTests API expects code + tests.
            // We pass sourceCode and invalid/partial tests?
            // Actually runTests takes { code, tests, language }.

            const result = await runTests({
                code: selectedModule.sourceCode,
                tests: generatedTests,
                language
            });

            toast.dismiss(toastId);
            if (result.success && result.testResult) {
                if (result.testResult.passed) {
                    toast.success('Tests Passed!');
                } else {
                    toast.error('Tests Failed');
                    // Optionally show logs
                }
            } else {
                toast.error('Failed to execute tests');
            }
        } catch (error) {
            toast.dismiss(toastId);
            toast.error('Error running tests');
        }
    };

    const handleCopy = () => {
        navigator.clipboard.writeText(generatedTests);
        toast.success('Copied to clipboard!');
    };

    const newCoverage = selectedModule ? Math.min(selectedModule.coverage + 40, 95) : 0;
    const newTestCount = selectedModule ? Math.floor((100 - selectedModule.coverage) / 10) : 0;

    return (
        <div className="improve-page">
            {/* Header */}
            <div className="improve-header">
                <button onClick={() => window.location.href = '/'} className="back-link">
                    <FiArrowLeft /> Back to Generate
                </button>
                <h1>üîß Improve Existing Tests</h1>
                <p>Analyze your project and generate additional tests to increase coverage</p>
            </div>

            {/* GitHub URL Input */}
            <div className="github-scan-section">
                <div className="github-input-row">
                    <input
                        type="text"
                        placeholder="https://github.com/username/repo"
                        value={githubUrl}
                        onChange={(e) => setGithubUrl(e.target.value)}
                        className="github-input"
                    />
                    <button
                        className="btn btn-primary"
                        onClick={handleScanGithub}
                        disabled={isScanning}
                    >
                        {isScanning ? 'Scanning...' : ' Scan Repo'}
                    </button>
                </div>
                {!projectInfo && <p className="input-hint">Enter GitHub URL or use demo project below</p>}
            </div>

            {/* Project Card */}
            <div className="project-card">
                <div className="project-info">
                    <FiFolder className="project-icon" />
                    <div>
                        <h2>{projectInfo?.name || 'LLM-Unit-Tests Backend'}</h2>
                        <p>{projectInfo ? `${projectInfo.files} files scanned` : 'Node.js REST API ‚Ä¢ 15 files ‚Ä¢ ~2000 lines ‚Ä¢ 3 test files'}</p>
                    </div>
                </div>
                <div className="project-stats">
                    <div className="stat-box">
                        <span className="stat-label">Average Coverage</span>
                        <span className={`stat-value ${getCoverageColor(avgCoverage)}`}>{avgCoverage}%</span>
                    </div>
                    <div className="stat-box">
                        <span className="stat-label">Target</span>
                        <span className="stat-value coverage-high">85%</span>
                    </div>
                </div>
            </div>

            {/* LLM Selector */}
            <div className="llm-selector">
                <span><FiCpu /> LLM Provider:</span>
                <select value={llmProvider} onChange={(e) => setLlmProvider(e.target.value)}>
                    <option value="gemini">Gemini 2.0</option>
                    <option value="deepseek">Deepseek</option>
                </select>
            </div>

            {/* Module Grid */}
            <div className="section-header">
                <h2>üìä Select Module to Improve</h2>
            </div>

            <div className="modules-grid">
                {modules.map((module) => (
                    <div
                        key={module.id}
                        className={`module-card ${selectedModule?.id === module.id ? 'selected' : ''}`}
                        onClick={() => handleModuleClick(module)}
                    >
                        <div className="module-header">
                            <FiFileText className="module-icon" />
                            <div>
                                <h3>{module.name}</h3>
                                <span className="module-path">{module.path}</span>
                            </div>
                            {/* Analyze button for unanalyzed files */}
                            {!module.analyzed && !module.isAnalyzing && (
                                <button
                                    className="btn btn-small btn-primary analyze-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleAnalyzeModule(module);
                                    }}
                                >
                                    Analyze
                                </button>
                            )}
                            {module.isAnalyzing && (
                                <span className="analyzing-badge">Analyzing...</span>
                            )}
                            {module.analyzed && (
                                <span className="analyzed-badge">Done</span>
                            )}
                        </div>

                        <div className="module-stats">
                            <div className="stat">
                                <span className="stat-value">{module.analyzed ? module.tests : '?'}</span>
                                <span className="stat-label">Tests</span>
                            </div>
                            <div className="stat">
                                <span className={`stat-value ${module.coverage ? getCoverageColor(module.coverage) : ''}`}>
                                    {module.coverage !== null ? `${module.coverage}%` : '?'}
                                </span>
                                <span className="stat-label">Coverage</span>
                            </div>
                            <div className="stat">
                                <span className="stat-value">{module.analyzed ? module.gaps.length : '?'}</span>
                                <span className="stat-label">Gaps</span>
                            </div>
                        </div>

                        {module.coverage !== null && (
                            <div className="coverage-bar">
                                <div
                                    className={`coverage-fill ${getCoverageColor(module.coverage)}`}
                                    style={{ width: `${module.coverage}%` }}
                                />
                                <div
                                    className="coverage-target"
                                    style={{ left: `${module.targetCoverage}%` }}
                                />
                            </div>
                        )}
                    </div>
                ))}
            </div>

            {/* Selected Module Details */}
            {selectedModule && (
                <div className="module-details">
                    <div className="details-header">
                        <div>
                            <h3>üìÑ {selectedModule.name}</h3>
                            <p className="details-path">{selectedModule.path}</p>
                        </div>
                        <div className="coverage-comparison">
                            <span className={getCoverageColor(selectedModule.coverage)}>
                                {selectedModule.coverage}%
                            </span>
                            <span className="arrow">‚Üí</span>
                            <span className="coverage-high">{selectedModule.targetCoverage}%</span>
                        </div>
                    </div>

                    <div className="gaps-section">
                        <h4>‚ö†Ô∏è Coverage Gaps to Fill:</h4>
                        <div className="gaps-grid">
                            {selectedModule.gaps.map((gap, idx) => (
                                <div key={idx} className={`gap-item priority-${gap.priority.toLowerCase()}`}>
                                    <FiAlertCircle className="gap-icon" />
                                    <div>
                                        <span className="gap-name">{gap.name}</span>
                                        <span className="gap-lines">Lines {gap.lines}</span>
                                    </div>
                                    <span className={`priority-badge ${gap.priority.toLowerCase()}`}>
                                        {gap.priority}
                                    </span>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="generate-section">
                        <button
                            className="btn btn-primary btn-large generate-btn"
                            onClick={handleGenerate}
                            disabled={isGenerating}
                        >
                            {isGenerating ? (
                                <>
                                    <span className="loading-spinner"></span>
                                    Generating with {llmProvider === 'gemini' ? 'Gemini' : 'Deepseek'}...
                                </>
                            ) : (
                                <>
                                    <FiZap />
                                    Generate Additional Tests
                                </>
                            )}
                        </button>
                        <p className="generate-hint">
                            AI will analyze existing {selectedModule.tests} tests and generate ~{newTestCount} additional test cases
                            to improve coverage from {selectedModule.coverage}% to ~{newCoverage}%
                        </p>
                    </div>
                </div>
            )}

            {/* Results */}
            {generatedTests && (
                <div className="results-section">
                    <div className="results-header">
                        <div>
                            <h2>‚úÖ Generated Additional Tests</h2>
                            <p className="results-meta">
                                {newTestCount} new test cases ‚Ä¢ Generated in {((generationTime || 3000) / 1000).toFixed(1)}s
                            </p>
                        </div>
                        <div className="coverage-improvement">
                            <span className={getCoverageColor(selectedModule.coverage)}>
                                {selectedModule.coverage}%
                            </span>
                            <span className="arrow">‚Üí</span>
                            <span className="coverage-high">{newCoverage}%</span>
                            <span className="improvement-badge">+{newCoverage - selectedModule.coverage}%</span>
                        </div>
                    </div>

                    <div className="code-preview">
                        <pre>{generatedTests}</pre>
                    </div>

                    <div className="results-actions">
                        <button className="btn btn-primary">
                            <FiPlay /> Run All Tests
                        </button>
                        <button className="btn btn-secondary" onClick={handleCopy}>
                            üìã Copy to Clipboard
                        </button>
                        <button className="btn btn-secondary">
                            üíæ Merge with {selectedModule.testFile.split('/').pop()}
                        </button>
                    </div>
                </div>
            )}
        </div>
    );
}

export default ImproveTests;
